<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pathpy.processes.process &#8212; pathpy 3.0.22 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/style.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/pathpy_logo.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>3.0.22</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../examples/index.html">Gallery</a></li>
                <li><a href="../../../tutorial.html">Tutorial</a></li>
                <li><a href="../../../api.html">API</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Example gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribution.html">Contributing</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for pathpy.processes.process</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Base classes for simulation of dynamical processes&quot;&quot;&quot;</span>
<span class="c1"># !/usr/bin/python -tt</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># File      : classes.py -- Base classes for processes</span>
<span class="c1"># Author    : Ingo Scholtes &lt;scholtes@uni-wuppertal.de&gt;</span>
<span class="c1"># Time-stamp: &lt;Thu 2021-05-06 19:17 ingo&gt;</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2016-2021 Pathpy Developers</span>
<span class="c1"># =============================================================================</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Set</span>

<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="kn">from</span> <span class="nn">pathpy.core.classes</span> <span class="kn">import</span> <span class="n">BaseClass</span>
<span class="kn">from</span> <span class="nn">pathpy.core.api</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">pathpy.models.network</span> <span class="kn">import</span> <span class="n">Network</span>
<span class="kn">from</span> <span class="nn">pathpy.models.directed_acyclic_graph</span> <span class="kn">import</span> <span class="n">DirectedAcyclicGraph</span>
<span class="kn">from</span> <span class="nn">pathpy.models.temporal_network</span> <span class="kn">import</span> <span class="n">TemporalNetwork</span><span class="p">,</span> <span class="n">TemporalNode</span>
<span class="kn">from</span> <span class="nn">pathpy</span> <span class="kn">import</span> <span class="n">tqdm</span><span class="p">,</span> <span class="n">logger</span>

<span class="c1"># create logger</span>
<span class="n">LOG</span> <span class="o">=</span> <span class="n">logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="BaseProcess"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess">[docs]</a><span class="k">class</span> <span class="nc">BaseProcess</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for all implementations of discrete-time dynamical processes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseProcess.__init__"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">:</span><span class="n">Network</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize process.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">())</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">network</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Network</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span> 

<div class="viewcode-block" id="BaseProcess.init"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.init">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Abstract method to initialize the process with a given seed state.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="BaseProcess.random_seed"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.random_seed">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">random_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Abstract method to generate a random seed state for the process.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="BaseProcess.step"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.step">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Abstract method to simulate a single step of the process. Returns </span>
<span class="sd">        an iterable of node uids whose state has been changed in this step.&quot;&quot;&quot;</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractproperty</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Abstract property returning the current time.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseProcess.state_to_color"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.state_to_color">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">state_to_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Abstract method mapping node states to RGB colors or color names.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="BaseProcess.node_state"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.node_state">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">node_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Abstract method returning the current state of a given node.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="BaseProcess.simulation_run"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.simulation_run">[docs]</a>    <span class="k">def</span> <span class="nf">simulation_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Abstract generator method that initializes the process, runs a number of steps and yields a tuple consisting of the current time and the set of nodes whose state has changed in each step.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">ret</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BaseProcess.run_experiment"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.run_experiment">[docs]</a>    <span class="k">def</span> <span class="nf">run_experiment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">runs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform one or more simulation runs of the process with a given number of steps.&quot;&quot;&quot;</span>

        <span class="c1"># Generate initializations for different runs</span>
        <span class="n">seeds</span><span class="p">:</span> <span class="n">List</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">runs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runs</span><span class="p">):</span>
                <span class="n">seeds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">runs</span><span class="p">:</span>
                <span class="n">seeds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">run_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">seeds</span><span class="p">):</span>
            
            <span class="c1"># initialize seed state and record initial state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">uids</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;run_id&#39;</span><span class="p">:</span> <span class="n">run_id</span><span class="p">,</span> <span class="s1">&#39;seed&#39;</span><span class="p">:</span> <span class="n">seed</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">v</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_state</span><span class="p">(</span><span class="n">v</span><span class="p">)})</span>

            <span class="c1"># simulate the given number of steps</span>
            <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">updated_nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_run</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
                <span class="c1"># print(updated_nodes)</span>
                <span class="c1"># record the new state of each changed node</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">updated_nodes</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;run_id&#39;</span><span class="p">:</span> <span class="n">run_id</span><span class="p">,</span> <span class="s1">&#39;seed&#39;</span><span class="p">:</span> <span class="n">seed</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">v</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_state</span><span class="p">(</span><span class="n">v</span><span class="p">)})</span>
            <span class="n">run_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseProcess.plot"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">run_id</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">timescale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display an interactive plot of the evolution of a process based on a recorded simulation experiment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: DataFrame</span>
<span class="sd">            A pandas dataframe containing the state changes recorded in a simulation of the process, as generated by function `run_experiment`</span>
<span class="sd">        </span>
<span class="sd">        run_id: Optional[int]=0</span>
<span class="sd">            The integer identifier of the simulation run contained in `data` that shall be visualized. </span>
<span class="sd">            If omitted, a default value of zero is used, i.e. the first simulation run in `data` will </span>
<span class="sd">            be visualized. </span>

<span class="sd">        timescale: Optional[int]=100</span>
<span class="sd">            Determines the speed of the visualisation. For the default value of 100, each simulation step</span>
<span class="sd">            will be displayed for 100 timesteps in the visualisation.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Optional keyword-arguments that will be passed to the plot function of the underlying instance </span>
<span class="sd">            of TemporalNetwork</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Generate 10 random walks and visualize the walk dynamics of the run with id 3</span>

<span class="sd">        &gt;&gt;&gt; n = pp.Network(directed=False)</span>
<span class="sd">        &gt;&gt;&gt; n.add_edge(&#39;a&#39;, &#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; rw = pp.processes.RandomWalk(n)</span>
<span class="sd">        &gt;&gt;&gt; data = rw.run_experiment(steps=100, runs=10)</span>
<span class="sd">        &gt;&gt;&gt; rw.plot(data, run_id=3)</span>

<span class="sd">        See Also:</span>
<span class="sd">        ---------</span>
<span class="sd">        TemporalNetwork, plot, RandomWalk, HigherOrderRandomWalk, EpidemicSIR</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">evolution</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;run_id&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">run_id</span><span class="p">]</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">evolution</span><span class="o">.</span><span class="n">min</span><span class="p">()[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">evolution</span><span class="o">.</span><span class="n">max</span><span class="p">()[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">start_time</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Run data does not contain time evolution&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># print(start_time)    </span>
        <span class="c1"># print(end_time)</span>
        
        <span class="c1"># create network with temporal attributes</span>
        <span class="n">tn</span> <span class="o">=</span> <span class="n">TemporalNetwork</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">directed</span><span class="p">)</span>        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">tn</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">TemporalNode</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">uid</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">TemporalNetwork</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">tedges</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">start_time</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
                    <span class="n">tn</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start_time</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="c1"># # set initial state</span>
            <span class="c1"># for v in tn.nodes.uids:</span>
            <span class="c1">#     tn.nodes[v][start_time, &#39;color&#39;] = self.state_to_color(self.node_state(v))</span>
            <span class="c1"># update state</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">evolution</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">tn</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]][</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_to_color</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">tn</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_time</span><span class="o">*</span><span class="n">timescale</span><span class="p">)</span>
            <span class="c1"># # set initial state</span>
            <span class="c1"># for v in tn.nodes.uids:</span>
            <span class="c1"># for index, row in evolution.loc[&#39;time&#39;==start_time].iterrows():</span>
            <span class="c1">#     tn.nodes[v][0, &#39;color&#39;] = self.state_to_color(evolution.loc[&#39;time&#39;==start_time][&#39;state&#39;])</span>
            <span class="c1"># update state</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">evolution</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">tn</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]][</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">timescale</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_to_color</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">])</span>
        
        
        <span class="k">return</span> <span class="n">tn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseProcess.to_directed_acylic_graph"><a class="viewcode-back" href="../../../generated/pathpy.processes.process.BaseProcess.html#pathpy.processes.epidemic_spreading.BaseProcess.to_directed_acylic_graph">[docs]</a>    <span class="k">def</span> <span class="nf">to_directed_acylic_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">run_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time_delta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DirectedAcyclicGraph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a directed acyclic graph representation of all state changes over time.</span>
<span class="sd">        In this graph an edge (v_t&#39; -&gt; w_t) indicates that node w changed to state x at time t after a </span>
<span class="sd">        connected node v previously changed its state to x at time t&#39; &lt; t (i.e. (v,w) exists in the network).</span>

<span class="sd">        A link (v-t&#39;) -&gt; (w-t) in the directed acyclic graph indicates that node v may have causally influenced node w at time t. As an example, for a an SIR epidemic spreading process, the DAG representation captures possible transmission routes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: DataFrame</span>
<span class="sd">            recorded state changes of nodes, as returned by `run_experiment`</span>

<span class="sd">        run_id: Optional[int]=0</span>
<span class="sd">            identifier of simulation run to turn into DAG</span>

<span class="sd">        time_delta: Optional[int]=None</span>
<span class="sd">            maximum time difference of possible influence, i.e. if set to delta, any state changes between connected nodes that are apart further than delta time steps are not considered. If None (default) the last prior state change of any connected node is considered, independent of the </span>
<span class="sd">            time distance</span>

<span class="sd">        states: Optional[Iterable[Any]]=None</span>
<span class="sd">            Only changes to states in this set will be considered. If None (default) all state changes will be considered</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">DirectedAcyclicGraph</span><span class="p">(</span><span class="n">uid</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">run_id</span><span class="p">))</span>
        <span class="n">run</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;run_id&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">run_id</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">run</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>            
            <span class="c1"># add temporal node            </span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">]</span>            
            <span class="k">if</span> <span class="n">states</span> <span class="ow">and</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">uid</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">dag</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">)</span>

            <span class="c1"># find predecessor of node v that last changed its state</span>
            <span class="n">predecessors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>

                <span class="c1"># get all state changes of node v prior to time t</span>
                <span class="n">candidates</span> <span class="o">=</span> <span class="n">run</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">run</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">v</span><span class="o">.</span><span class="n">uid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">run</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">t</span><span class="p">)]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

                    <span class="c1"># find time stamp and new state of last state change</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                    <span class="n">last_time</span> <span class="o">=</span> <span class="n">candidates</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
                    <span class="n">last_state</span> <span class="o">=</span> <span class="n">candidates</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="s1">&#39;state&#39;</span><span class="p">]</span>

                    <span class="c1"># check last state change and time difference</span>
                    <span class="k">if</span>  <span class="n">last_state</span> <span class="ow">in</span> <span class="n">states</span> <span class="ow">and</span> <span class="p">(</span><span class="n">time_delta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">last_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">time_delta</span><span class="p">):</span>
                        <span class="n">pred_uid</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">last_time</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pred_uid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                            <span class="n">predecessors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">pred_uid</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">last_time</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">last_state</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">predecessors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">pred_uid</span><span class="p">])</span>
                        <span class="c1"># predecessors = [&#39;{0}-{1}&#39;.format(v.uid, t_p)]                        </span>
                    <span class="c1">#elif :                        </span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">predecessors</span><span class="p">:</span>
                <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">uid</span><span class="p">])</span>
            
        <span class="k">return</span> <span class="n">dag</span></div></div>


</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2016-2021, Pathpy Developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>